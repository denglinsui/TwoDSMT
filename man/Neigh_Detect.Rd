% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spatial_Detection.R
\name{Neigh_Detect}
\alias{Neigh_Detect}
\title{Neighbor Detection}
\usage{
Neigh_Detect(hh, X, Dist, Sigma.eps, detect.m = "top.k", mu = NULL)
}
\arguments{
\item{hh}{an integer vector indicating the number of neighbors for each location.}

\item{X}{a n*m matrix representing the observations, m is the number of locations, n is the number of observations at each location.}

\item{Dist}{a m*m matrixes representing the distance matrix between points.}

\item{Sigma.eps}{a m*m matrix representing the covariance matrix for noises.}

\item{detect.m}{a character representing the detecting method, currently only the k-nearest neighbor, "top.k", is available.}

\item{mu}{mu is a vector representing the true population mean (Usually unavailable).}
}
\value{
list; Ta is a numerical vector representing the auxiliary statistics;
Va is a numerical vector representing the variance of auxiliary statistics;
VmVa.cov is a numerical vector representing the covariance between primary and auxiliary statistics;
ind is an integer vector representing the indexes for implementing nonparametric empirical Bayes;
mua is a numerical vector representing the population mean of auxiliary statistics (Usually unavailable).
}
\description{
Neighbor Detection: 1. Detect the neighors (K-nearest neighbors) of each location according to the Distance matrix; 2. Calculate auxiliary test statistics;
3. Calculate the variance of primary and auxiliary test statistics and covariance between them
}
\examples{
library(dplyr)
library(fda)
library(qvalue)
# Basic Setting
set.seed(1234)
dig <- 7 # digits precision
n <- 1 # observation number at each point
m <- 120 # point size
q <- 0.1 # fdr level
const <- q # const for stablizing
# Generate data
point <- matrix(seq(0,1,length.out=m), ncol=1)
Dist.p <- as.matrix(dist(point))
I_S <- Init_Setting_1D(mu_type = "Dense",Cov_type = "Weak",
                       magnitude=2,mu_gen_machine="mvnorm",point=point)
mu <- I_S$mu
Sigma.eps.p <- I_S$Sigma.eps.p
X <- MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma.eps.p)
X <- matrix(X, nrow = n)
sgm <- sqrt(diag(Sigma.eps.p))
Tm <- apply(X,2,function(x){sum(x)/sqrt(n)})/sgm # Generate primary statistics
Tm <- round(Tm,dig)
p.value <- 1 - pnorm(Tm) # Generate one-side p.value
# Run BH algorithm
result.BH <- qvalue(p.value,pi0 = 1)
selected.BH <- which(result.BH$qvalues<=q)

# Run 1D algorithm (1D(BH))
res.1D <- OneD_Detect(Tm, q,  pis = NULL,const = const, tau.tm = 1)
selected.1D <- res.1D$selected
Tm.star <- res.1D$tm.min
max.rej <- res.1D$max.rej

# Run 2D algorith with 2 neighbors (2D(BH))
hh <- 2 # neighbor number
hh.seq <- rep(hh,m)
Neigh_Detect_res <- Neigh_Detect(hh = hh.seq, X = X,
                                 Dist = Dist.p, Sigma.eps = Sigma.eps.p,
                                 detect.m = "top.k")
Ta <- Neigh_Detect_res$Ta
Va <- Neigh_Detect_res$Va
VmVa.cov <- Neigh_Detect_res$VmVa.cov
ind <- Neigh_Detect_res$ind
mua <- Neigh_Detect_res$mua

res.2D <- Spatial_Detect_exact_grp_BH_down(Tm, Ta, Va, VmVa.cov, ind,
                                           q, max.rej,
                                           Tm.star = Tm.star,
                                           Ta.star = Inf,
                                           const = const)
selected.2D <- res.2D$selected
tm <- res.2D$tm0
ta <- res.2D$ta0

# fdp and power
fdp(selected.BH,mu);fdp(selected.1D,mu);fdp(selected.2D,mu)
Pow(selected.BH,mu);Pow(selected.1D,mu);Pow(selected.2D,mu)
}
