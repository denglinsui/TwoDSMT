% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spatial_Detection.R
\name{Spatial_Detect_exact_BH_down_reTm_reTa}
\alias{Spatial_Detect_exact_BH_down_reTm_reTa}
\title{Two dimension detection (weighted BH based)}
\usage{
Spatial_Detect_exact_BH_down_reTm_reTa(
  Tm,
  Ta,
  Va,
  VmVa.cov,
  ind,
  q = 0.1,
  max.rej = NULL,
  pis = NULL,
  ws = NULL,
  cutoff = NULL,
  pws.tm.star = 0,
  pws.ta.star = 0,
  const = 0,
  seed = 0,
  dig = 7,
  ws.fun = function(pis) {
     (1 - pis)/pis
 },
  n.group.max = 10,
  is.exact.group = F,
  tol = 1e-09,
  tau.tm = 1,
  tau.ta = 1,
  adj.up = 0.9,
  adj.ud = 1.1,
  mua = NULL,
  is.quick.stop = F,
  stop.step = 10,
  is.fullset = F,
  EmpMethod = c("NPEB", "DeCor")
)
}
\arguments{
\item{Tm}{a numerical vector representing the primary statistics.}

\item{Ta}{a numerical vector representing the auxiliary statistics.}

\item{Va}{a numerical vector representing the variance of auxiliary statistics.}

\item{VmVa.cov}{a numerical vector representing the covariance between primary and auxiliary statistics.}

\item{ind}{an integer vector representing the indexes for implementing nonparametric empirical Bayes.}

\item{q}{a numerical value representing the target fdr level.}

\item{max.rej}{an integer indicating the current maximum rejection number that controls fdr under q.}

\item{pis}{a numerical vector representing the probability of being null.}

\item{ws}{a numerical vector indicating the non-null weights.}

\item{cutoff}{a matrix with two columns representing the candidate cutoff set and it should be noted that the cutoffs are ordered for searching convenience;}

\item{pws.tm.star}{a numerical value representing the threshold found by one dimensional detection with non-null weights based on the primary statistics.}

\item{pws.ta.star}{a numerical value representing the threshold found by one dimensional detection with non-null weights based on the auxiliary statistics.}

\item{const}{a numerical value ensuring the selection stability, usually be target fdr level.}

\item{seed}{a numerical value indicating the simulation seed (can be omit).}

\item{dig}{an integer representing the digit precision.}

\item{ws.fun}{a function for weighting, depending on the null proportion.}

\item{n.group.max}{an integer determining how many groups do we use to accelerate.}

\item{is.exact.group}{a logical representing whether the group is exact.}

\item{tol}{a numerical value to control the calculation precision.}

\item{tau.tm}{a numerical value representing the censor level for p-values.}

\item{tau.ta}{a numerical value representing the censor level for p-values.}

\item{adj.up}{a numerical value to ensure the precision during calculation, it should be below 1;}

\item{adj.ud}{a numerical value to ensure the precision during calculation, it should be above 1;}

\item{mua}{a numerical vector representing the population mean of auxiliary statistics (Usually unavailable).}

\item{is.quick.stop}{a bool value representing whether we should stop early.}

\item{stop.step}{an integer indicating the maximal step for no valuable finding(estimate fdr<target fdr level).}

\item{is.fullset}{a bool value representing whether we take all partitons of full set for implementing NPEB}

\item{EmpMethod}{a character indicating which method we choose to estimate the empirical distribution.}
}
\value{
list;
selected is an integer vector consisting of selected locations;
tm0 a numerical value representing the threshold for the weighted p-value of primary statistics;
ta0 a numerical value representing the threshold for the weighted p-value of auxiliary statistics;
final.fdr a numerical value representing the final estimated false discovery rate.
}
\description{
Searching for the optimal threshold for the two dimensional weighted BH procedure based on primary and auxiliary statistics.
Practically, we reorder p-values according to the non-null weights ws.
}
\examples{
library(dplyr)
library(fda)
library(qvalue)
# Basic Setting
set.seed(1234)
dig <- 7 # digits precision
n <- 1 # observation number at each point
m <- 120 # point size
q <- 0.1 # fdr level
const <- q # const for stablizing
# Generate data
point <- matrix(seq(0,1,length.out=m), ncol=1)
Dist.p <- as.matrix(dist(point))
I_S <- Init_Setting_1D(mu_type = "Dense",Cov_type = "Weak",
                       magnitude=2,mu_gen_machine="mvnorm",point=point)
mu <- I_S$mu
Sigma.eps.p <- I_S$Sigma.eps.p
X <- MASS::mvrnorm(n = n, mu = mu, Sigma = Sigma.eps.p)
X <- matrix(X, nrow = n)
sgm <- sqrt(diag(Sigma.eps.p))
Tm <- apply(X,2,function(x){sum(x)/sqrt(n)})/sgm # Generate primary statistics
Tm <- round(Tm,dig)
p.value <- 1 - pnorm(Tm) # Generate one-side p.value
# Run SABHA algorithm
tau = 0.5;eps = 0.1; TV_bd = 2
alpha_ADMM = 10^2; beta = 10^3; eta = 5; max_iters = 5000; converge_thr = 1e-4 # parameters for ADMM
ADMM_params = c(alpha_ADMM,beta,eta,max_iters,converge_thr)
qhat = Solve_q_TV_1dim(p.value, tau, eps, TV_bd, ADMM_params)
SABHA_method = function(pvals, qhat, alpha, tau){
pvals[pvals>tau] = Inf
khat=max(c(0,which(sort(qhat*pvals)<=alpha*(1:length(pvals))/length(pvals))))
which(qhat*pvals<=alpha*khat/length(pvals))
}
sab.selected <- SABHA_method(p.value, qhat, q, tau)

# Run 1D algorithm (SABHA)
ws.sabha.fun <- function(x){1/x}
res.1D.sabha <- OneD_Detect_w(Tm, q, pis = qhat,
                              ws.fun = ws.sabha.fun,
                              const = const,
                              tau.tm = 1)
tm.star.sabha <- res.1D.sabha$tm.min
max.rej.sabha <- res.1D.sabha$max.rej
selected.1D.sabha <- res.1D.sabha$selected

# Run 2D algorith with 2 neighbors (2D(SA))
hh <- 2 # neighbor number
hh.seq <- rep(hh,m)
Neigh_Detect_res <- Neigh_Detect(hh = hh.seq, X = X,
                                 Dist = Dist.p, Sigma.eps = Sigma.eps.p,
                                 detect.m = "top.k")
Ta <- Neigh_Detect_res$Ta
Va <- Neigh_Detect_res$Va
VmVa.cov <- Neigh_Detect_res$VmVa.cov
ind <- Neigh_Detect_res$ind
mua <- Neigh_Detect_res$mua

res.2D.sabha <- Spatial_Detect_exact_BH_down_reTm_reTa(Tm, Ta, Va,
                                                       VmVa.cov, ind,
                                                       q,
                                                       max.rej = max.rej.sabha,
                                                       pis = qhat,
                                                       pws.tm.star = tm.star.sabha,
                                                       pws.ta.star = 0,
                                                       const = const,
                                                       ws.fun = ws.sabha.fun,
                                                       n.group.max = 5)
selected.2D.sabha <- res.2D.sabha$selected
tm <- res.2D.sabha$tm0
ta <- res.2D.sabha$ta0
# fdp and power
fdp(sab.selected,mu);fdp(selected.1D.sabha,mu);fdp(selected.2D.sabha,mu)
Pow(sab.selected,mu);Pow(selected.1D.sabha,mu);Pow(selected.2D.sabha,mu)
}
